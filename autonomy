#!/bin/bash
# Agentic Autonomy Core
# The AI decides. This is just the interface.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
AUTONOMY_DIR="$SCRIPT_DIR"
WORKSPACE="/root/.openclaw/workspace"
CONFIG="$AUTONOMY_DIR/config.json"
TASKS_DIR="$AUTONOMY_DIR/tasks"
AGENTS_DIR="$AUTONOMY_DIR/agents"
TOOLS_DIR="$AUTONOMY_DIR/tools"
LOGS_DIR="$AUTONOMY_DIR/logs"
STATE_DIR="$AUTONOMY_DIR/state"

mkdir -p "$TASKS_DIR" "$AGENTS_DIR" "$TOOLS_DIR" "$LOGS_DIR" "$STATE_DIR"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Get config value
get_config() {
    jq -r "$1" "$CONFIG" 2>/dev/null
}

# Check limits
check_limits() {
    local limit_type="$1"
    local current=0
    local max=0
    
    # Get current count based on type
    case "$limit_type" in
        tasks)
            current=$(ls -1 "$TASKS_DIR"/*.json 2>/dev/null | wc -l)
            ;;
        sub_agents)
            current=$(get_config '.workstation.running_agents | length // 0')
            ;;
        schedules)
            current=$(get_config '.workstation.schedules | length // 0')
            ;;
        *)
            current=$(get_config ".workstation.${limit_type} | length // 0")
            ;;
    esac
    
    # Get max limit
    max=$(get_config ".agentic_config.hard_limits.max_${limit_type} // 0")
    
    # Handle null/empty values
    current=${current:-0}
    max=${max:-0}
    
    if [[ "$current" -ge "$max" && "$max" -gt 0 ]]; then
        echo "LIMIT_EXCEEDED:$limit_type:$current/$max"
        return 1
    fi
    return 0
}

# Log agentic activity
log_activity() {
    local action="$1"
    local details="${2:-{}}"
    echo "{\"timestamp\":\"$(date -Iseconds)\",\"action\":\"$action\",\"details\":$details}" >> "$LOGS_DIR/agentic.jsonl"
}

# Show agentic status
show_agentic_status() {
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  AGENTIC AUTONOMY STATUS"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    
    local active=$(get_config '.workstation.active')
    local mode=$(get_config '.mode')
    
    if [[ "$active" == "true" ]]; then
        echo -e "  ${GREEN}â—${NC} Workstation: ACTIVE"
    else
        echo -e "  ${RED}â—‹${NC} Workstation: INACTIVE"
    fi
    echo "  Mode: ${CYAN}$mode${NC}"
    
    # Show autonomy level
    local level=$(get_config '.agentic_config.autonomy_level // "semi-autonomous"')
    echo "  Level: ${CYAN}$level${NC}"
    echo ""
    
    # Show current tasks
    local tasks=$(ls -1 "$TASKS_DIR"/*.json 2>/dev/null | wc -l)
    echo "  Active Tasks: $tasks"
    if [[ "$tasks" -gt 0 ]]; then
        for task_file in "$TASKS_DIR"/*.json; do
            [[ -f "$task_file" ]] || continue
            local task_name=$(basename "$task_file" .json)
            local status=$(jq -r '.status // "unknown"' "$task_file")
            local priority=$(jq -r '.priority // "normal"' "$task_file")
            echo "    â€¢ $task_name [$status] ($priority)"
        done
    fi
    echo ""
    
    # Show running agents
    local agents=$(get_config '.workstation.running_agents | length')
    echo "  Running Agents: $agents"
    
    # Show schedules
    local schedules=$(get_config '.workstation.schedules | length')
    echo "  Scheduled Tasks: $schedules"
    
    # Show created tools
    local tools=$(ls -1 "$TOOLS_DIR"/* 2>/dev/null | wc -l)
    echo "  Custom Tools: $tools"
    
    # Show limits
    echo ""
    echo "  Hard Limits:"
    echo "    Max Tasks: $(get_config '.agentic_config.hard_limits.max_concurrent_tasks')"
    echo "    Max Agents: $(get_config '.agentic_config.hard_limits.max_sub_agents')"
    echo "    Max Schedules: $(get_config '.agentic_config.hard_limits.max_schedules')"
    echo "    Daily Token Budget: $(get_config '.agentic_config.hard_limits.daily_token_budget')"
    
    # Show token usage
    local tokens=$(get_config '.workstation.token_usage_today')
    echo ""
    echo "  Today's Token Usage: $tokens"
    
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
}

# Activate agentic mode
cmd_on() {
    local tmp_file="${CONFIG}.tmp"
    
    jq '.workstation.active = true | .last_activated = "'$(date -Iseconds)'"' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
    
    echo -e "${GREEN}âœ“${NC} Agentic Autonomy ACTIVATED"
    echo ""
    echo "  The AI now decides what to work on."
    echo "  On each heartbeat, the AI will:"
    echo "    1. Check pending tasks and schedules"
    echo "    2. Reason about priorities"
    echo "    3. Decide what to do next"
    echo "    4. Execute (within hard limits)"
    echo ""
    echo "  Hard limits protect against runaway usage."
    echo "  Run 'autonomy status' to monitor."
    
    log_activity "workstation_activated" "{}"
    
    # Auto-start heartbeat daemon if not already running
    local scheduler_type=$(get_config '.scheduler.type // "daemon"')
    if [[ "$scheduler_type" == "daemon" ]]; then
        if [[ -f "$AUTONOMY_DIR/state/heartbeat-daemon.pid" ]]; then
            local daemon_pid=$(cat "$AUTONOMY_DIR/state/heartbeat-daemon.pid" 2>/dev/null)
            if ! ps -p "$daemon_pid" > /dev/null 2>&1; then
                rm -f "$AUTONOMY_DIR/state/heartbeat-daemon.pid"
                echo ""
                echo "  Starting heartbeat daemon..."
                "$AUTONOMY_DIR/daemon.sh" start > /dev/null 2>&1
                sleep 1
                if [[ -f "$AUTONOMY_DIR/state/heartbeat-daemon.pid" ]]; then
                    echo -e "  ${GREEN}âœ“${NC} Daemon started (auto-runs every 10 min)"
                fi
            else
                echo ""
                echo -e "  ${GREEN}âœ“${NC} Daemon already running (PID: $daemon_pid)"
            fi
        else
            echo ""
            echo "  Starting heartbeat daemon..."
            "$AUTONOMY_DIR/daemon.sh" start > /dev/null 2>&1
            sleep 1
            if [[ -f "$AUTONOMY_DIR/state/heartbeat-daemon.pid" ]]; then
                echo -e "  ${GREEN}âœ“${NC} Daemon started (auto-runs every 10 min)"
            fi
        fi
    fi
}

# Deactivate
cmd_off() {
    local tmp_file="${CONFIG}.tmp"
    
    jq '.workstation.active = false | .last_deactivated = "'$(date -Iseconds)'"' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
    
    echo -e "${RED}â—‹${NC} Agentic Autonomy DEACTIVATED"
    echo "  Workstation stopped."
    
    log_activity "workstation_deactivated" "{}"
}

# Create a new task
cmd_task() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list)
            echo "Active Tasks:"
            for task_file in "$TASKS_DIR"/*.json; do
                [[ -f "$task_file" ]] || continue
                local name=$(basename "$task_file" .json)
                local status=$(jq -r '.status' "$task_file")
                local desc=$(jq -r '.description' "$task_file")
                echo "  â€¢ $name: $desc [$status]"
            done
            ;;
            
        create)
            shift
            local name="$1"
            local description="${2:-No description}"
            
            if [[ -z "$name" ]]; then
                echo "Usage: autonomy task create <name> [description]"
                return 1
            fi
            
            # Check limits
            if ! check_limits "tasks"; then
                echo -e "${RED}Error:${NC} Task limit reached. Complete existing tasks first."
                return 1
            fi
            
            cat > "$TASKS_DIR/${name}.json" << EOF
{
  "name": "$name",
  "description": "$description",
  "status": "pending",
  "priority": "normal",
  "created": "$(date -Iseconds)",
  "assignee": "self",
  "subtasks": [],
  "completed": false,
  "attempts": 0,
  "max_attempts": $(get_config '.agentic_config.completion_criteria.max_attempts // 3'),
  "verification": null,
  "evidence": []
}
EOF
            
            echo -e "${GREEN}âœ“${NC} Task created: $name"
            log_activity "task_created" "{\"name\": \"$name\"}"
            ;;
            
        complete)
            shift
            local name="$1"
            local verification="${2:-}"  # Optional verification proof
            
            if [[ -f "$TASKS_DIR/${name}.json" ]]; then
                # Check if verification is required
                local require_verify=$(get_config '.agentic_config.completion_criteria.require_verification // true')
                
                if [[ "$require_verify" == "true" && -z "$verification" ]]; then
                    echo -e "${YELLOW}âš ${NC} Verification required before marking complete"
                    echo "  Provide proof the task works:"
                    echo "    autonomy task complete $name 'Tested: [describe what was tested]'"
                    return 1
                fi
                
                # Update task with verification
                local tmp_task_file="${TASKS_DIR}/${name}.tmp.$$"
                jq --arg verify "$verification" --arg date "$(date -Iseconds)" '.status = "completed" | .completed = true | .completed_at = $date | .verification = $verify | .attempts = (.attempts // 0) + 1' "$TASKS_DIR/${name}.json" > "$tmp_task_file" && mv "$tmp_task_file" "$TASKS_DIR/${name}.json"
                
                echo -e "${GREEN}âœ“${NC} Task completed: $name"
                if [[ -n "$verification" ]]; then
                    echo "  Verification: $verification"
                fi
                log_activity "task_completed" "{\"name\": \"$name\", \"verification\": \"$verification\"}"
                
                # Send email notification if enabled
                if [[ -f "$AUTONOMY_DIR/lib/notify.sh" ]]; then
                    bash "$AUTONOMY_DIR/lib/notify.sh" task-complete "$name" "$verification" > /dev/null 2>&1 || true
                fi
            else
                echo -e "${RED}Error:${NC} Task not found: $name"
                return 1
            fi
            ;;
            
        *)
            echo "Usage: autonomy task {list|create <name> [desc]|complete <name>}"
            ;;
    esac
}

# Spawn a sub-agent
cmd_spawn() {
    local task="$1"
    
    if [[ -z "$task" ]]; then
        echo "Usage: autonomy spawn <task-description>"
        return 1
    fi
    
    # Check limits
    local agents=$(get_config '.workstation.running_agents | length')
    local max_agents=$(get_config '.agentic_config.hard_limits.max_sub_agents')
    
    if [[ "$agents" -ge "$max_agents" ]]; then
        echo -e "${RED}Error:${NC} Agent limit reached ($agents/$max_agents)"
        return 1
    fi
    
    local agent_id="agent-$(date +%s)"
    
    # Spawn via sessions_spawn
    echo "Spawning agent: $agent_id"
    echo "Task: $task"
    
    # Record the agent
    local tmp_file="${CONFIG}.tmp"
    jq '.workstation.running_agents += [{"id": "'$agent_id'", "task": "'$task'", "started": "'$(date -Iseconds)'", "status": "running"}]' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
    
    log_activity "agent_spawned" "{\"id\": \"$agent_id\", \"task\": \"$task\"}"
    
    echo -e "${GREEN}âœ“${NC} Agent spawned: $agent_id"
    echo "  The agent will work on: $task"
}

# Schedule a recurring task
cmd_schedule() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list)
            echo "Scheduled Tasks:"
            get_config '.workstation.schedules[]' | while read -r schedule; do
                echo "  â€¢ $schedule"
            done
            ;;
            
        add)
            shift
            local interval="$1"
            local task="$2"
            
            if [[ -z "$interval" || -z "$task" ]]; then
                echo "Usage: autonomy schedule add <interval> <task>"
                echo "Example: autonomy schedule add '30m' 'check email'"
                return 1
            fi
            
            # Check limits
            local schedules=$(get_config '.workstation.schedules | length')
            local max_schedules=$(get_config '.agentic_config.hard_limits.max_schedules')
            
            if [[ "$schedules" -ge "$max_schedules" ]]; then
                echo -e "${RED}Error:${NC} Schedule limit reached ($schedules/$max_schedules)"
                return 1
            fi
            
            local tmp_file="${CONFIG}.tmp"
            jq '.workstation.schedules += [{"interval": "'$interval'", "task": "'$task'", "last_run": null, "created": "'$(date -Iseconds)'"}]' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
            
            echo -e "${GREEN}âœ“${NC} Scheduled: $task every $interval"
            log_activity "schedule_added" "{\"interval\": \"$interval\", \"task\": \"$task\"}"
            ;;
            
        remove)
            shift
            local index="$1"
            
            local tmp_file="${CONFIG}.tmp"
            jq 'del(.workstation.schedules['$index'])' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
            
            echo -e "${GREEN}âœ“${NC} Schedule removed"
            ;;
            
        *)
            echo "Usage: autonomy schedule {list|add <interval> <task>|remove <index>}"
            ;;
    esac
}

# Create a custom tool
cmd_tool() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list)
            echo "Custom Tools:"
            for tool in "$TOOLS_DIR"/*; do
                [[ -f "$tool" ]] || continue
                echo "  â€¢ $(basename "$tool")"
            done
            ;;
            
        create)
            shift
            local name="$1"
            
            if [[ -z "$name" ]]; then
                echo "Usage: autonomy tool create <name>"
                echo "Then write the tool code."
                return 1
            fi
            
            cat > "$TOOLS_DIR/$name" << 'TOOL_HEADER'
#!/bin/bash
# Custom tool created by Agentic Autonomy
# Created: $(date -Iseconds)

TOOL_HEADER
            chmod +x "$TOOLS_DIR/$name"
            
            # Record in config
            local tmp_file="${CONFIG}.tmp"
            jq '.workstation.created_tools += ["'$name'"]' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
            
            echo -e "${GREEN}âœ“${NC} Tool created: $TOOLS_DIR/$name"
            echo "  Edit it to add functionality."
            log_activity "tool_created" "{\"name\": \"$name\"}"
            ;;
            
        *)
            echo "Usage: autonomy tool {list|create <name>}"
            ;;
    esac
}

# Install/configure scheduler
# Install/configure scheduler
cmd_install() {
    local scheduler_type="${1:-daemon}"
    
    case "$scheduler_type" in
        daemon)
            echo "Switching to built-in daemon scheduler..."
            
            # Stop cron if exists
            if crontab -l 2>/dev/null | grep -q "autonomy.*daemon"; then
                (crontab -l 2>/dev/null | grep -v "autonomy.*daemon") | crontab -
                echo "  Removed cron entry"
            fi
            
            # Update config
            local tmp_file="${CONFIG}.tmp"
            jq '.scheduler.type = "daemon" | .scheduler.auto_start = true' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
            
            # Start daemon
            "$AUTONOMY_DIR/daemon.sh" restart 2>/dev/null || "$AUTONOMY_DIR/daemon.sh" start
            
            echo -e "${GREEN}âœ“${NC} Now using built-in daemon"
            echo "  Auto-starts when you run 'autonomy on'"
            ;;
            
        cron)
            echo "Switching to system cron scheduler..."
            
            # Stop daemon
            "$AUTONOMY_DIR/daemon.sh" stop 2>/dev/null
            
            # Add cron entry
            local cron_cmd="cd $AUTONOMY_DIR && bash daemon.sh once >> logs/cron.log 2>&1"
            local cron_entry="*/10 * * * * $cron_cmd"
            
            # Remove existing entries first
            (crontab -l 2>/dev/null | grep -v "autonomy.*daemon") | crontab -
            
            # Add new entry
            (crontab -l 2>/dev/null; echo "$cron_entry") | crontab -
            
            # Update config
            local tmp_file="${CONFIG}.tmp"
            jq '.scheduler.type = "cron" | .scheduler.auto_start = false' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
            
            echo -e "${GREEN}âœ“${NC} Now using system cron"
            echo "  Cron entry added: Every 10 minutes"
            echo "  Verify with: crontab -l"
            ;;
            
        auto)
            echo "Auto-detecting best scheduler..."
            
            # Check if cron is available
            if command -v crontab >/dev/null 2>&1; then
                # Try to use cron (more reliable)
                cmd_install cron
            else
                # Fall back to daemon
                cmd_install daemon
            fi
            ;;
            
        *)
            echo "Usage: autonomy install {daemon|cron|auto}"
            echo ""
            echo "Scheduler types:"
            echo "  daemon  - Built-in daemon (default, works everywhere)"
            echo "  cron    - System cron (survives reboots, requires crontab)"
            echo "  auto    - Auto-detect best option"
            echo ""
            echo "Current: $(get_config '.scheduler.type // \"daemon\"')"
            ;;
    esac
}

# Work on something (the main entry point)
cmd_work() {
    local instruction="$*"
    
    if [[ -z "$instruction" ]]; then
        echo "Usage: autonomy work <instruction>"
        echo ""
        echo "Examples:"
        echo '  autonomy work "Build a memory system for tracking conversations"'
        echo '  autonomy work "Research API rate limits and document findings"'
        echo '  autonomy work "Create a tool that checks disk space daily"'
        return 1
    fi
    
    # Check if workstation is active
    local active=$(get_config '.workstation.active')
    if [[ "$active" != "true" ]]; then
        echo -e "${YELLOW}âš ${NC} Workstation not active. Run 'autonomy on' first."
        return 1
    fi
    
    # Create a task from the instruction
    local task_name="task-$(date +%s)"
    cmd_task create "$task_name" "$instruction"
    
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  WORK ASSIGNMENT"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "  Instruction: $instruction"
    echo "  Task ID: $task_name"
    echo ""
    echo "  The AI will now:"
    echo "    1. REASON about the instruction"
    echo "    2. DECIDE how to approach it"
    echo "    3. CREATE a plan if needed"
    echo "    4. EXECUTE (within hard limits)"
    echo "    5. REPORT back when complete"
    echo ""
    echo "  Hard limits in effect:"
    echo "    â€¢ Max $(get_config '.agentic_config.hard_limits.max_file_edits_per_session') file edits"
    echo "    â€¢ Max $(get_config '.agentic_config.hard_limits.max_web_searches') web searches"
    echo "    â€¢ Daily token budget: $(get_config '.agentic_config.hard_limits.daily_token_budget')"
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    
    log_activity "work_assigned" "{\"task\": \"$task_name\", \"instruction\": \"$instruction\"}"
    
    # The AI now takes over and decides what to do
    # This is where the agentic part happens - the AI reasons and acts
    echo "  AI: Analyzing instruction..."
    echo "  AI: Reasoning about approach..."
    echo "  AI: Ready to execute."
    echo ""
    echo "  (The AI is now in control - check logs for progress)"
}

# Update from GitHub (keep this)
cmd_update() {
    if [[ -f "$AUTONOMY_DIR/checks/self_update.sh" ]]; then
        bash "$AUTONOMY_DIR/checks/self_update.sh" "${1:-check}"
    else
        echo "Self-update not available"
    fi
}

# Manage autonomy levels
cmd_level() {
    if [[ -f "$AUTONOMY_DIR/lib/autonomy-levels.sh" ]]; then
        bash "$AUTONOMY_DIR/lib/autonomy-levels.sh" "$@"
    else
        echo "Autonomy levels not available"
    fi
}

# Configuration wizard
cmd_wizard() {
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  Autonomy Configuration Wizard"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    
    # Step 1: Workstation activation
    echo "Step 1: Workstation Activation"
    read -p "Enable agentic autonomy? (y/n): " enable
    if [[ "$enable" == "y" ]]; then
        cmd_on
    fi
    echo ""
    
    # Step 2: Scheduler setup
    echo "Step 2: Scheduler Setup"
    echo "  1) Built-in daemon (recommended)"
    echo "  2) System cron"
    read -p "Choose scheduler (1/2): " scheduler
    if [[ "$scheduler" == "1" ]]; then
        cmd_install daemon
    elif [[ "$scheduler" == "2" ]]; then
        cmd_install cron
    fi
    echo ""
    
    # Step 3: Web UI
    echo "Step 3: Web UI"
    read -p "Start web UI? (y/n): " webui
    if [[ "$webui" == "y" ]]; then
        cd "$AUTONOMY_DIR" && nohup python3 web_ui.py > /tmp/webui.log 2>&1 &
        echo "Web UI started on http://localhost:8767"
    fi
    echo ""
    
    # Step 4: Completion setup
    echo "Step 4: Shell Completion"
    echo "Add this to your ~/.bashrc:"
    echo "  source $AUTONOMY_DIR/completion.sh"
    echo ""
    
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  Wizard Complete!"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Quick commands:"
    echo "  autonomy status     - Check status"
    echo "  autonomy work       - Give the AI a task"
    echo "  autonomy daemon     - Control the daemon"
}

# Manage aliases
cmd_alias() {
    local alias_file="$AUTONOMY_DIR/state/aliases"
    mkdir -p "$AUTONOMY_DIR/state"
    
    case "${1:-list}" in
        list)
            echo "Defined aliases:"
            if [[ -f "$alias_file" ]]; then
                cat "$alias_file" | while read line; do
                    name=$(echo "$line" | cut -d= -f1)
                    cmd=$(echo "$line" | cut -d= -f2-)
                    echo "  $name -> $cmd"
                done
            else
                echo "  No aliases defined"
            fi
            echo ""
            echo "Usage: autonomy alias add <name> '<command>'"
            echo "       autonomy alias remove <name>"
            ;;
        add)
            shift
            local name="$1"
            shift
            local cmd="$*"
            echo "${name}=${cmd}" >> "$alias_file"
            echo "Added alias: $name -> $cmd"
            ;;
        remove)
            shift
            local name="$1"
            if [[ -f "$alias_file" ]]; then
                grep -v "^${name}=" "$alias_file" > "${alias_file}.tmp" && mv "${alias_file}.tmp" "$alias_file"
                echo "Removed alias: $name"
            fi
            ;;
        *)
            echo "Usage: autonomy alias {list|add <name> '<command>'|remove <name>}"
            ;;
    esac
}

# Check for updates
cmd_check_updates() {
    local current=$(get_config '.version // "2.0.0"')
    echo "Current version: $current"
    
    # Check if git repo
    if [[ -d "$AUTONOMY_DIR/.git" ]]; then
        cd "$AUTONOMY_DIR"
        git fetch origin 2>/dev/null
        behind=$(git rev-list HEAD..origin/main --count 2>/dev/null || echo 0)
        if [[ $behind -gt 0 ]]; then
            echo "ðŸ“¦ Update available: $behind commits behind"
            echo "Run 'autonomy update apply' to update"
        else
            echo "âœ… Up to date"
        fi
    else
        echo "Not a git repository - manual updates required"
    fi
}

# Show help
show_help() {
    cat << EOF
Agentic Autonomy - AI-driven self-improvement for OpenClaw

QUICK START:
  onboard                  Interactive setup wizard (first time)
  onboard quick            Quick auto-setup
  work "<instruction>"      Give the AI a task and let it decide how
  on                       Activate agentic mode (auto-starts daemon)
  off                      Deactivate

HEARTBEAT DAEMON (Self-contained scheduling):
  daemon start             Start heartbeat daemon (every 10 min)
  daemon stop              Stop the daemon
  daemon restart           Restart the daemon
  daemon status            Check if daemon is running
  daemon once              Run a single heartbeat cycle now
  daemon logs              View daemon logs

SCHEDULER INSTALLATION:
  install daemon           Use built-in daemon (default, works everywhere)
  install cron             Use system cron (survives reboots)
  install auto             Auto-detect best option
                           Current: $(get_config '.scheduler.type // "daemon"')

AUTONOMY LEVELS:
  level                    Show current autonomy level
  level list               List available levels
  level set supervised     All actions require approval
  level set semi-autonomous Balanced automation (default)
  level set fully-autonomous Maximum automation within hard limits

ANTI-HALLUCINATION (Required):
  task complete <name> "proof"  Must provide proof task actually works
  
  Good:  task complete X "Tested: logs tokens, file exists with data"
  Bad:   task complete X (no proof = rejection)

AGENT SPAWNING:
  spawn "<task>"           Spawn a sub-agent for parallel work
                           (max $(get_config '.agentic_config.hard_limits.max_sub_agents') agents)

SCHEDULING:
  schedule list            Show recurring schedules
  schedule add <int> <task> Add schedule (e.g., '30m', '1h')
                           (max $(get_config '.agentic_config.hard_limits.max_schedules') schedules)

TASK DEPENDENCIES:
  deps add <task> <dep>    Add dependency (task requires dep first)
  deps remove <task> <dep> Remove dependency
  deps check <task>        Check if task can start
  deps list <task>         List dependencies
  deps ready               Show tasks ready to start
  deps graph               Show dependency graph
  deps setup               Interactive setup wizard

GITHUB ACTIONS:
  gh status                Show workflow status
  gh trigger <workflow>    Trigger workflow run
  gh watch <run-id>        Watch workflow run
  gh logs <run-id>         View workflow logs
  gh create-workflow <name> Create new workflow
  gh setup                 Configure GitHub integration

TEMPLATES:
  template list            List available templates
  template create <tmpl> <name>  Create task from template
  template show <template>  Show template details
  template save <task> <tmpl>  Save task as template
  template new             Create custom template

TOOL CREATION:
  tool list                Show custom tools
  tool create <name>       Create a new tool

SELF-UPDATE:
  update check             Check for updates from GitHub
  update apply             Apply latest update

NOTIFICATIONS:
  notify status            Check email notification status
  notify setup             Configure email notifications
  notify test              Send test email

DATABASE:
  db init                  Initialize database (SQLite)
  db status                Show database status
  db sync-to-db            Sync JSON tasks to database
  db sync-from-db          Export database to JSON files
  db setup                 Configure database backend

API AUTH:
  api-auth generate        Generate new API token
  api-auth validate        Validate a token
  api-auth list            List all tokens
  api-auth revoke          Revoke a token
  api-auth status          Show rate limit status
  api-auth setup           Interactive setup wizard

MONITORING:
  status                   Show workstation status and limits
  logs                     View activity logs
  heartbeat recent         Show recent heartbeat activity
  heartbeat stats          Show heartbeat statistics
  check-updates            Check for available updates

UTILITIES:
  wizard                   Interactive configuration wizard
  alias list               List command aliases
  alias add <name> <cmd>   Add command alias
  alias remove <name>      Remove command alias
  version                  Show version

EXAMPLES:
  autonomy work "Build a system to track my daily token usage"
  autonomy work "Research best practices for memory management"
  autonomy spawn "Analyze the codebase for security issues"
  autonomy schedule add 1h "Check for new emails"
  autonomy alias add st "status"
  autonomy wizard

HARD LIMITS (Safety):
  â€¢ Max $(get_config '.agentic_config.hard_limits.max_concurrent_tasks') concurrent tasks
  â€¢ Max $(get_config '.agentic_config.hard_limits.max_sub_agents') sub-agents
  â€¢ Max $(get_config '.agentic_config.hard_limits.max_schedules') schedules
  â€¢ $(get_config '.agentic_config.hard_limits.daily_token_budget') daily token budget
  â€¢ Some actions require approval
EOF
}

# Main dispatch
case "${1:-status}" in
    onboard)
        shift
        "$AUTONOMY_DIR/onboard" "$@"
        ;;
    status)
        show_agentic_status
        ;;
    on)
        cmd_on
        ;;
    off)
        cmd_off
        ;;
    work)
        shift
        cmd_work "$@"
        ;;
    task)
        shift
        cmd_task "$@"
        ;;
    spawn)
        shift
        cmd_spawn "$@"
        ;;
    schedule)
        shift
        cmd_schedule "$@"
        ;;
    deps)
        shift
        "$AUTONOMY_DIR/deps" "$@"
        ;;
    gh)
        shift
        "$AUTONOMY_DIR/gh" "$@"
        ;;
    tool)
        shift
        cmd_tool "$@"
        ;;
    update)
        shift
        cmd_update "$@"
        ;;
    daemon)
        shift
        "$AUTONOMY_DIR/daemon.sh" "$@"
        ;;
    install)
        shift
        cmd_install "$@"
        ;;
    level)
        shift
        cmd_level "$@"
        ;;
    logs)
        tail -20 "$LOGS_DIR/agentic.jsonl" 2>/dev/null || echo "No logs yet"
        ;;
    wizard)
        cmd_wizard
        ;;
    alias)
        shift
        cmd_alias "$@"
        ;;
    notify)
        shift
        "$AUTONOMY_DIR/lib/notify.sh" "$@"
        ;;
    db)
        shift
        "$AUTONOMY_DIR/db" "$@"
        ;;
    template)
        shift
        "$AUTONOMY_DIR/template" "$@"
        ;;
    api-auth)
        shift
        "$AUTONOMY_DIR/api-auth" "$@"
        ;;
    heartbeat)
        shift
        "$AUTONOMY_DIR/heartbeat" "$@"
        ;;
    version|-v|--version)
        echo "Autonomy v$(get_config '.version // "2.0.0"')"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        # Check if it's an alias
        if [[ -f "$AUTONOMY_DIR/state/aliases" ]]; then
            alias_cmd=$(grep "^$1=" "$AUTONOMY_DIR/state/aliases" | cut -d= -f2-)
            if [[ -n "$alias_cmd" ]]; then
                echo "Running alias: $1 -> $alias_cmd"
                bash "$AUTONOMY_DIR/autonomy" $alias_cmd "${@:2}"
                exit 0
            fi
        fi
        echo "Unknown command: $1"
        echo "Run 'autonomy help' for usage"
        exit 1
        ;;
esac
