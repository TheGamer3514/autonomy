#!/bin/bash
# Agentic Autonomy Core
# The AI decides. This is just the interface.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
AUTONOMY_DIR="$SCRIPT_DIR"
WORKSPACE="/root/.openclaw/workspace"
CONFIG="$AUTONOMY_DIR/config.json"
TASKS_DIR="$AUTONOMY_DIR/tasks"
AGENTS_DIR="$AUTONOMY_DIR/agents"
TOOLS_DIR="$AUTONOMY_DIR/tools"
LOGS_DIR="$AUTONOMY_DIR/logs"
STATE_DIR="$AUTONOMY_DIR/state"

mkdir -p "$TASKS_DIR" "$AGENTS_DIR" "$TOOLS_DIR" "$LOGS_DIR" "$STATE_DIR"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Get config value
get_config() {
    jq -r "$1" "$CONFIG" 2>/dev/null
}

# Check limits
check_limits() {
    local limit_type="$1"
    local current=0
    local max=0
    
    # Get current count based on type
    case "$limit_type" in
        tasks)
            current=$(ls -1 "$TASKS_DIR"/*.json 2>/dev/null | wc -l)
            ;;
        sub_agents)
            current=$(get_config '.workstation.running_agents | length // 0')
            ;;
        schedules)
            current=$(get_config '.workstation.schedules | length // 0')
            ;;
        *)
            current=$(get_config ".workstation.${limit_type} | length // 0")
            ;;
    esac
    
    # Get max limit
    max=$(get_config ".agentic_config.hard_limits.max_${limit_type} // 0")
    
    # Handle null/empty values
    current=${current:-0}
    max=${max:-0}
    
    if [[ "$current" -ge "$max" && "$max" -gt 0 ]]; then
        echo "LIMIT_EXCEEDED:$limit_type:$current/$max"
        return 1
    fi
    return 0
}

# Log agentic activity
log_activity() {
    local action="$1"
    local details="${2:-{}}"
    echo "{\"timestamp\":\"$(date -Iseconds)\",\"action\":\"$action\",\"details\":$details}" >> "$LOGS_DIR/agentic.jsonl"
}

# Show agentic status
show_agentic_status() {
    echo ""
    echo "═══════════════════════════════════════════════════════════"
    echo "  AGENTIC AUTONOMY STATUS"
    echo "═══════════════════════════════════════════════════════════"
    echo ""
    
    local active=$(get_config '.workstation.active')
    local mode=$(get_config '.mode')
    
    if [[ "$active" == "true" ]]; then
        echo -e "  ${GREEN}●${NC} Workstation: ACTIVE"
    else
        echo -e "  ${RED}○${NC} Workstation: INACTIVE"
    fi
    echo "  Mode: ${CYAN}$mode${NC}"
    echo ""
    
    # Show current tasks
    local tasks=$(ls -1 "$TASKS_DIR"/*.json 2>/dev/null | wc -l)
    echo "  Active Tasks: $tasks"
    if [[ "$tasks" -gt 0 ]]; then
        for task_file in "$TASKS_DIR"/*.json; do
            [[ -f "$task_file" ]] || continue
            local task_name=$(basename "$task_file" .json)
            local status=$(jq -r '.status // "unknown"' "$task_file")
            local priority=$(jq -r '.priority // "normal"' "$task_file")
            echo "    • $task_name [$status] ($priority)"
        done
    fi
    echo ""
    
    # Show running agents
    local agents=$(get_config '.workstation.running_agents | length')
    echo "  Running Agents: $agents"
    
    # Show schedules
    local schedules=$(get_config '.workstation.schedules | length')
    echo "  Scheduled Tasks: $schedules"
    
    # Show created tools
    local tools=$(ls -1 "$TOOLS_DIR"/* 2>/dev/null | wc -l)
    echo "  Custom Tools: $tools"
    
    # Show limits
    echo ""
    echo "  Hard Limits:"
    echo "    Max Tasks: $(get_config '.agentic_config.hard_limits.max_concurrent_tasks')"
    echo "    Max Agents: $(get_config '.agentic_config.hard_limits.max_sub_agents')"
    echo "    Max Schedules: $(get_config '.agentic_config.hard_limits.max_schedules')"
    echo "    Daily Token Budget: $(get_config '.agentic_config.hard_limits.daily_token_budget')"
    
    # Show token usage
    local tokens=$(get_config '.workstation.token_usage_today')
    echo ""
    echo "  Today's Token Usage: $tokens"
    
    echo ""
    echo "═══════════════════════════════════════════════════════════"
}

# Activate agentic mode
cmd_on() {
    local tmp_file="${CONFIG}.tmp"
    
    jq '.workstation.active = true | .last_activated = "'$(date -Iseconds)'"' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
    
    echo -e "${GREEN}✓${NC} Agentic Autonomy ACTIVATED"
    echo ""
    echo "  The AI now decides what to work on."
    echo "  On each heartbeat, the AI will:"
    echo "    1. Check pending tasks and schedules"
    echo "    2. Reason about priorities"
    echo "    3. Decide what to do next"
    echo "    4. Execute (within hard limits)"
    echo ""
    echo "  Hard limits protect against runaway usage."
    echo "  Run 'autonomy status' to monitor."
    
    log_activity "workstation_activated" "{}"
}

# Deactivate
cmd_off() {
    local tmp_file="${CONFIG}.tmp"
    
    jq '.workstation.active = false | .last_deactivated = "'$(date -Iseconds)'"' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
    
    echo -e "${RED}○${NC} Agentic Autonomy DEACTIVATED"
    echo "  Workstation stopped."
    
    log_activity "workstation_deactivated" "{}"
}

# Create a new task
cmd_task() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list)
            echo "Active Tasks:"
            for task_file in "$TASKS_DIR"/*.json; do
                [[ -f "$task_file" ]] || continue
                local name=$(basename "$task_file" .json)
                local status=$(jq -r '.status' "$task_file")
                local desc=$(jq -r '.description' "$task_file")
                echo "  • $name: $desc [$status]"
            done
            ;;
            
        create)
            shift
            local name="$1"
            local description="${2:-No description}"
            
            if [[ -z "$name" ]]; then
                echo "Usage: autonomy task create <name> [description]"
                return 1
            fi
            
            # Check limits
            if ! check_limits "tasks"; then
                echo -e "${RED}Error:${NC} Task limit reached. Complete existing tasks first."
                return 1
            fi
            
            cat > "$TASKS_DIR/${name}.json" << EOF
{
  "name": "$name",
  "description": "$description",
  "status": "pending",
  "priority": "normal",
  "created": "$(date -Iseconds)",
  "assignee": "self",
  "subtasks": [],
  "completed": false,
  "attempts": 0,
  "max_attempts": $(get_config '.agentic_config.completion_criteria.max_attempts // 3'),
  "verification": null,
  "evidence": []
}
EOF
            
            echo -e "${GREEN}✓${NC} Task created: $name"
            log_activity "task_created" "{\"name\": \"$name\"}"
            ;;
            
        complete)
            shift
            local name="$1"
            local verification="${2:-}"  # Optional verification proof
            
            if [[ -f "$TASKS_DIR/${name}.json" ]]; then
                # Check if verification is required
                local require_verify=$(get_config '.agentic_config.completion_criteria.require_verification // true')
                
                if [[ "$require_verify" == "true" && -z "$verification" ]]; then
                    echo -e "${YELLOW}⚠${NC} Verification required before marking complete"
                    echo "  Provide proof the task works:"
                    echo "    autonomy task complete $name 'Tested: [describe what was tested]'"
                    return 1
                fi
                
                # Update task with verification
                local tmp_task_file="${TASKS_DIR}/${name}.tmp.$$"
                jq --arg verify "$verification" --arg date "$(date -Iseconds)" '.status = "completed" | .completed = true | .completed_at = $date | .verification = $verify | .attempts = (.attempts // 0) + 1' "$TASKS_DIR/${name}.json" > "$tmp_task_file" && mv "$tmp_task_file" "$TASKS_DIR/${name}.json"
                
                echo -e "${GREEN}✓${NC} Task completed: $name"
                if [[ -n "$verification" ]]; then
                    echo "  Verification: $verification"
                fi
                log_activity "task_completed" "{\"name\": \"$name\", \"verification\": \"$verification\"}"
            else
                echo -e "${RED}Error:${NC} Task not found: $name"
                return 1
            fi
            ;;
            
        *)
            echo "Usage: autonomy task {list|create <name> [desc]|complete <name>}"
            ;;
    esac
}

# Spawn a sub-agent
cmd_spawn() {
    local task="$1"
    
    if [[ -z "$task" ]]; then
        echo "Usage: autonomy spawn <task-description>"
        return 1
    fi
    
    # Check limits
    local agents=$(get_config '.workstation.running_agents | length')
    local max_agents=$(get_config '.agentic_config.hard_limits.max_sub_agents')
    
    if [[ "$agents" -ge "$max_agents" ]]; then
        echo -e "${RED}Error:${NC} Agent limit reached ($agents/$max_agents)"
        return 1
    fi
    
    local agent_id="agent-$(date +%s)"
    
    # Spawn via sessions_spawn
    echo "Spawning agent: $agent_id"
    echo "Task: $task"
    
    # Record the agent
    local tmp_file="${CONFIG}.tmp"
    jq '.workstation.running_agents += [{"id": "'$agent_id'", "task": "'$task'", "started": "'$(date -Iseconds)'", "status": "running"}]' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
    
    log_activity "agent_spawned" "{\"id\": \"$agent_id\", \"task\": \"$task\"}"
    
    echo -e "${GREEN}✓${NC} Agent spawned: $agent_id"
    echo "  The agent will work on: $task"
}

# Schedule a recurring task
cmd_schedule() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list)
            echo "Scheduled Tasks:"
            get_config '.workstation.schedules[]' | while read -r schedule; do
                echo "  • $schedule"
            done
            ;;
            
        add)
            shift
            local interval="$1"
            local task="$2"
            
            if [[ -z "$interval" || -z "$task" ]]; then
                echo "Usage: autonomy schedule add <interval> <task>"
                echo "Example: autonomy schedule add '30m' 'check email'"
                return 1
            fi
            
            # Check limits
            local schedules=$(get_config '.workstation.schedules | length')
            local max_schedules=$(get_config '.agentic_config.hard_limits.max_schedules')
            
            if [[ "$schedules" -ge "$max_schedules" ]]; then
                echo -e "${RED}Error:${NC} Schedule limit reached ($schedules/$max_schedules)"
                return 1
            fi
            
            local tmp_file="${CONFIG}.tmp"
            jq '.workstation.schedules += [{"interval": "'$interval'", "task": "'$task'", "last_run": null, "created": "'$(date -Iseconds)'"}]' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
            
            echo -e "${GREEN}✓${NC} Scheduled: $task every $interval"
            log_activity "schedule_added" "{\"interval\": \"$interval\", \"task\": \"$task\"}"
            ;;
            
        remove)
            shift
            local index="$1"
            
            local tmp_file="${CONFIG}.tmp"
            jq 'del(.workstation.schedules['$index'])' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
            
            echo -e "${GREEN}✓${NC} Schedule removed"
            ;;
            
        *)
            echo "Usage: autonomy schedule {list|add <interval> <task>|remove <index>}"
            ;;
    esac
}

# Create a custom tool
cmd_tool() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list)
            echo "Custom Tools:"
            for tool in "$TOOLS_DIR"/*; do
                [[ -f "$tool" ]] || continue
                echo "  • $(basename "$tool")"
            done
            ;;
            
        create)
            shift
            local name="$1"
            
            if [[ -z "$name" ]]; then
                echo "Usage: autonomy tool create <name>"
                echo "Then write the tool code."
                return 1
            fi
            
            cat > "$TOOLS_DIR/$name" << 'TOOL_HEADER'
#!/bin/bash
# Custom tool created by Agentic Autonomy
# Created: $(date -Iseconds)

TOOL_HEADER
            chmod +x "$TOOLS_DIR/$name"
            
            # Record in config
            local tmp_file="${CONFIG}.tmp"
            jq '.workstation.created_tools += ["'$name'"]' "$CONFIG" > "$tmp_file" && mv "$tmp_file" "$CONFIG"
            
            echo -e "${GREEN}✓${NC} Tool created: $TOOLS_DIR/$name"
            echo "  Edit it to add functionality."
            log_activity "tool_created" "{\"name\": \"$name\"}"
            ;;
            
        *)
            echo "Usage: autonomy tool {list|create <name>}"
            ;;
    esac
}

# Work on something (the main entry point)
cmd_work() {
    local instruction="$*"
    
    if [[ -z "$instruction" ]]; then
        echo "Usage: autonomy work <instruction>"
        echo ""
        echo "Examples:"
        echo '  autonomy work "Build a memory system for tracking conversations"'
        echo '  autonomy work "Research API rate limits and document findings"'
        echo '  autonomy work "Create a tool that checks disk space daily"'
        return 1
    fi
    
    # Check if workstation is active
    local active=$(get_config '.workstation.active')
    if [[ "$active" != "true" ]]; then
        echo -e "${YELLOW}⚠${NC} Workstation not active. Run 'autonomy on' first."
        return 1
    fi
    
    # Create a task from the instruction
    local task_name="task-$(date +%s)"
    cmd_task create "$task_name" "$instruction"
    
    echo ""
    echo "═══════════════════════════════════════════════════════════"
    echo "  WORK ASSIGNMENT"
    echo "═══════════════════════════════════════════════════════════"
    echo ""
    echo "  Instruction: $instruction"
    echo "  Task ID: $task_name"
    echo ""
    echo "  The AI will now:"
    echo "    1. REASON about the instruction"
    echo "    2. DECIDE how to approach it"
    echo "    3. CREATE a plan if needed"
    echo "    4. EXECUTE (within hard limits)"
    echo "    5. REPORT back when complete"
    echo ""
    echo "  Hard limits in effect:"
    echo "    • Max $(get_config '.agentic_config.hard_limits.max_file_edits_per_session') file edits"
    echo "    • Max $(get_config '.agentic_config.hard_limits.max_web_searches') web searches"
    echo "    • Daily token budget: $(get_config '.agentic_config.hard_limits.daily_token_budget')"
    echo ""
    echo "═══════════════════════════════════════════════════════════"
    echo ""
    
    log_activity "work_assigned" "{\"task\": \"$task_name\", \"instruction\": \"$instruction\"}"
    
    # The AI now takes over and decides what to do
    # This is where the agentic part happens - the AI reasons and acts
    echo "  AI: Analyzing instruction..."
    echo "  AI: Reasoning about approach..."
    echo "  AI: Ready to execute."
    echo ""
    echo "  (The AI is now in control - check logs for progress)"
}

# Update from GitHub (keep this)
cmd_update() {
    if [[ -f "$AUTONOMY_DIR/checks/self_update.sh" ]]; then
        bash "$AUTONOMY_DIR/checks/self_update.sh" "${1:-check}"
    else
        echo "Self-update not available"
    fi
}

# Show help
show_help() {
    cat << EOF
Agentic Autonomy - AI-driven self-improvement for OpenClaw

QUICK START:
  work "<instruction>"      Give the AI a task and let it decide how
  on                       Activate agentic mode
  off                      Deactivate

ANTI-HALLUCINATION (Required):
  task complete <name> "proof"  Must provide proof task actually works
  
  Good:  task complete X "Tested: logs tokens, file exists with data"
  Bad:   task complete X (no proof = rejection)

AGENT SPAWNING:
  spawn "<task>"           Spawn a sub-agent for parallel work
                           (max $(get_config '.agentic_config.hard_limits.max_sub_agents') agents)

SCHEDULING:
  schedule list            Show recurring schedules
  schedule add <int> <task> Add schedule (e.g., '30m', '1h')
                           (max $(get_config '.agentic_config.hard_limits.max_schedules') schedules)

TOOL CREATION:
  tool list                Show custom tools
  tool create <name>       Create a new tool

SELF-UPDATE:
  update check             Check for updates from GitHub
  update apply             Apply latest update

MONITORING:
  status                   Show workstation status and limits
  logs                     View activity logs

EXAMPLES:
  autonomy work "Build a system to track my daily token usage"
  autonomy work "Research best practices for memory management"
  autonomy work "Create a dashboard showing all my scheduled tasks"
  autonomy spawn "Analyze the codebase for security issues"
  autonomy schedule add 1h "Check for new emails"

HARD LIMITS (Safety):
  • Max $(get_config '.agentic_config.hard_limits.max_concurrent_tasks') concurrent tasks
  • Max $(get_config '.agentic_config.hard_limits.max_sub_agents') sub-agents
  • Max $(get_config '.agentic_config.hard_limits.max_schedules') schedules
  • $(get_config '.agentic_config.hard_limits.daily_token_budget') daily token budget
  • Some actions require approval
EOF
}

# Main dispatch
case "${1:-status}" in
    status)
        show_agentic_status
        ;;
    on)
        cmd_on
        ;;
    off)
        cmd_off
        ;;
    work)
        shift
        cmd_work "$@"
        ;;
    task)
        shift
        cmd_task "$@"
        ;;
    spawn)
        shift
        cmd_spawn "$@"
        ;;
    schedule)
        shift
        cmd_schedule "$@"
        ;;
    tool)
        shift
        cmd_tool "$@"
        ;;
    update)
        shift
        cmd_update "$@"
        ;;
    logs)
        tail -20 "$LOGS_DIR/agentic.jsonl" 2>/dev/null || echo "No logs yet"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "Unknown command: $1"
        echo "Run 'autonomy help' for usage"
        exit 1
        ;;
esac
